# VideoSchedman 2.0

## Что нового

Итак, оглядываясь на свой предыдущий опыт в проектировании библиотек и программ, я могу сделать вывод, что говнокодить у меня получается лучше, чем кропотливо сидеть и обдумывать модульность и расширяемость программ. При проектировании **VideoSchedman** я не имел точного понимания как в принципе устроена библиотека FFMpeg и, не успев до конца разобраться, лез писать кодус. После конкретного code review, я пересмотрел свои взгляды на проектирование программ, а также больше познакомился с упомянутой ранее библиотекой, что внесло определенный вклад в чистоту и прозрачность моего решения. В первую очередь, я стремлюсь предоставить пользователям и разработчикам наиболее удобное взаимодействие с моим программным интерфейсом, чтобы с ходу можно было понять (минимально обращаясь к документации) как устроен тот или иной метод/класс. Поэтому, прикинув первичные сущности, я постарался продумать способ взаимодействия разработчиков с ними, параллельно продумывая будущую реализацию.

##  Пример

```C#
var videos = GetVideos(path);
var tempNames = new string[] { "nature", "animal", "city" };
var watermarkPath = GetWatermarkImagePath();

var ffmpeg = Factory.CreateFFMpeg();
var pipe = ffmpeg.CreatePipeline();
pipe.AddVideos(videos)
    .Preprocess(config => config.ToSameTypes().ToTransportStream())
    .Subsequence(Subsec.TemplateName, tempNames)
    .Loop(Loop.Template, file => file.Duration < TimeSpan.From("00:00:10"), loopCount: 2)
    .Watermark(Watermark.StaticImage, path:watermarkPath, opacity:20)
    .Result.Quality(Quality.FHD);

await ffmpeg.StartMiddlewareAsync(pipe);
```

## Как все устроено

### Связи

**Factory** - статический класс, отвечает за логику создания и построения объекта-типа **FFMpegEngine**. Основной метод `CreateFFMpeg()`.

**FFMpegEngine** - класс, инкапсулирует логику создания основной видеодорожки (**Pipeline**), а также ответственный за кодирование и конвертацию видеофайлов в итоговый проект. Содержит методы `CreatePipeline()`, `StartMiddlewareAsync()`.

**Pipeline** - класс, предоставляет "открытый интерфейс" настройки результирующего видеопроекта. Содержит методы `AddVideos()`, `Subsequence()`, `Loop()`, `Watermark()` и публичное поле Result, являющееся объектом-типа **FileMeta**. 

**FileMeta** - класс, позволяет настроить кодировку, разрешение, качество итогового файла.

**FileMiddleware** - класс, настраивается при помощи объекта-типа **FileMiddlewareBuilder**. Сам класс "запечатывает" в себе параметры в конвейер, необходимые для дальнейшей обработки файлов в классе **FFMpegEngine**.

**FileMiddlewareBuilder** - класс-строитель, позволяет создавать и настраивать **FileMiddleware**.



**Pipeline** конфигурирует в себе целый проект (настройка качества, формата), а **FileMiddleware** обрабатывает отдельные файлы и приводит их к общему формату, необходимому для дальнейшей безошибочной обработки.

### Конвейер обработки видеофайла

Клиент вызывает статический метод **CreateFFMpeg** класса **Factory**, инициализирующий объект-типа **FFmpegEngine**. После создания объекта, клиент вызывает метод **CreatePipeline**, который возвращает ссылку на объект класса **Pipeline**. Данный объект представляет из себя хранилище настроек итогового проекта: качество, формат, кодировка, фпс, а также позволяет настроить отдельные видео, либо видео в связке, например, наложить водную марку на видеодорожку, определить места затухания, эффекты, цикличность, последовательность, возможность сгруппировать по названиям, темам, тегам и тд. По логике, может использоваться в нескольких проектах, поскольку хранит в себе исключительно информацию о том "Как мне нужно обработать входные файлы". Похожий класс, определяющий логику применения всех изменений, которые были указаны в **Pipeline** - объект **FileMiddleware**. Но прежде, данный объект необходимо построить, используя класс **FileMiddlewareBuilder**. Построение объекта **FileMiddleware**, обусловлено необходимостью запечатывания информации о конвертации файлов к общему виду, чтобы дальнейшие операции по конкатенации видеороликов не заканчивались ошибкой или искаженным результатом. [Смотри источник](https://stackoverflow.com/questions/7333232/how-to-concatenate-two-mp4-files-using-ffmpeg). Чтобы применить все изменения к файлам и наконец получить итоговый проект, запустим процесс обработки, используя метод **StartMiddlewareAsync** в экземпляре класса **FileMiddleware**, в который в качестве аргумента передаем ранее настроенный **Pipeline**. 

